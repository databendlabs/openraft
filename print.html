<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Actix Raft</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The ActixRaft user guide.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="raft.html"><strong aria-hidden="true">2.</strong> Raft</a></li><li class="chapter-item expanded "><a href="network.html"><strong aria-hidden="true">3.</strong> Network</a></li><li class="chapter-item expanded "><a href="storage.html"><strong aria-hidden="true">4.</strong> Storage</a></li><li class="chapter-item expanded "><a href="cluster-controls.html"><strong aria-hidden="true">5.</strong> Cluster Controls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cluster-formation.html"><strong aria-hidden="true">5.1.</strong> Cluster Formation</a></li><li class="chapter-item expanded "><a href="dynamic-membership.html"><strong aria-hidden="true">5.2.</strong> Dynamic Membership</a></li></ol></li><li class="chapter-item expanded "><a href="metrics.html"><strong aria-hidden="true">6.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="get-to-it.html"><strong aria-hidden="true">7.</strong> Get To It</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Actix Raft</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#actix-raft" id="actix-raft">actix raft</a></h1>
<p><a href="https://travis-ci.com/railgun-rs/actix-raft"><img src="https://travis-ci.com/railgun-rs/actix-raft.svg?branch=master" alt="Build Status" /></a>
<a href="https://crates.io/crates/actix-raft"><img src="https://img.shields.io/crates/v/actix-raft.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/actix-raft"><img src="https://docs.rs/actix-raft/badge.svg" alt="docs.rs" /></a>
<a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT%2FApache--2.0-blue" alt="License" /></a>
<img src="https://img.shields.io/crates/d/actix-raft.svg" alt="Crates.io" />
<img src="https://img.shields.io/crates/dv/actix-raft.svg" alt="Crates.io" />
<a href=""><img src="https://img.shields.io/github/issues-raw/railgun-rs/actix-raft.svg" alt="GitHub issues open" /></a>
<a href=""><img src="https://img.shields.io/github/issues-closed-raw/railgun-rs/actix-raft.svg" alt="GitHub issues closed" /></a></p>
<p>An implementation of the <a href="https://raft.github.io/">Raft distributed consensus protocol</a> using the <a href="https://github.com/actix/actix">Actix actor framework</a>. Blazing fast Rust, a modern consensus protocol, an outstanding actor framework. This project intends to provide a backbone for the next generation of distributed data storage systems (SQL, NoSQL, KV, Streaming &amp;c) built with Rust. Please ⭐ on <a href="https://github.com/railgun-rs/actix-raft">github</a>!</p>
<p><a href="https://railgun-rs.github.io/actix-raft">The guide</a> is the best place to get started, followed by <a href="https://docs.rs/actix-raft/latest/actix_raft/">the docs</a> for more in-depth details.</p>
<p>This crate differs from other Raft implementations in that:</p>
<ul>
<li>It is fully reactive and embraces the async ecosystem. It is driven by actual Raft related events taking place in the system as opposed to being driven by a <code>tick</code> operation. Batching of messages during replication is still used whenever possible for maximum throughput.</li>
<li>Storage and network integration is well defined via the two traits <code>RaftStorage</code> &amp; <code>RaftNetwork</code>. This provides applications maximum flexibility in being able to choose their storage and networking mediums. This also allows for the storage interface to be synchronous or asynchronous based on the storage engine used, and allows for easy integration with the actix ecosystem's networking components for efficient async networking. See the <a href="https://railgun-rs.github.io/actix-raft/storage.html">storage</a> &amp; <a href="https://railgun-rs.github.io/actix-raft/network.html">network</a> chapters of the guide.</li>
<li>Submitting Raft RPCs &amp; client requests to a running Raft node is also well defined via the Actix message types defined in the <code>messages</code> module in this crate. The API for this system is clear and concise. See the <a href="https://railgun-rs.github.io/actix-raft/raft.html">raft</a> chapter in the guide.</li>
<li>It fully supports dynamic cluster membership changes according to the Raft spec. See the <a href="https://railgun-rs.github.io/actix-raft/dynamic-membership.html"><code>dynamic membership</code></a> chapter in the guide.</li>
<li>Details on initial cluster formation, and how to effectively do so from an application level perspective, are discussed in the <a href="https://railgun-rs.github.io/actix-raft/cluster-formation.html">cluster formation</a> chapter in the guide.</li>
</ul>
<p>This implementation strictly adheres to the <a href="https://raft.github.io/raft.pdf">Raft spec</a> (<em>pdf warning</em>), and all data models use the same nomenclature found in the spec for better understandability. This implementation of Raft has integration tests covering all aspects of a Raft cluster's lifecycle including: cluster formation, dynamic membership changes, snapshotting, writing data to a live cluster and more.</p>
<p>If you are building an application using this Raft implementation, open an issue and let me know! I would love to add your project's name &amp; logo to a users list in this project.</p>
<h3><a class="header" href="#contributing" id="contributing">contributing</a></h3>
<p>Check out the <a href="https://github.com/railgun-rs/actix-raft/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> guide for more details on getting started with contributing to this project.</p>
<h3><a class="header" href="#license" id="license">license</a></h3>
<p>actix-raft is licensed under the terms of the MIT License or the Apache License 2.0, at your choosing.</p>
<hr />
<p><strong>NOTE:</strong> the appearance of the &quot;section&quot; symbols <code>§</code> throughout this project are references to specific sections of the Raft spec.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This crate's <code>Raft</code> type is an Actix actor which is intended to run within some parent application, which traditionally will be some sort of data storage system (SQL, NoSQL, KV store, AMQP, Streaming, whatever). Inasmuch as the <code>Raft</code> instance is an actor, it is expected that the parent application is also built upon the Actix actor framework, though that is not technically required.</p>
<p>To use this crate, applications must also implement the <code>RaftStorage</code> &amp; <code>RaftNetwork</code> traits. See the <a href="https://railgun-rs.github.io/actix-raft/storage.html">storage</a> &amp; <a href="https://railgun-rs.github.io/actix-raft/network.html">network</a> chapters for details on what these traits represent and how to implement them. In brief, the implementing types must be actors which can handle specific message types which correspond to everything needed for Raft storage and networking.</p>
<h3><a class="header" href="#deep-dive" id="deep-dive">deep dive</a></h3>
<p>To get started, applications can define a type alias which declares the types which are going to be used for the application's data, errors, <code>RaftNetwork</code> impl &amp; <code>RaftStorage</code> impl.</p>
<p>First, let's define the new application's main data type &amp; a response type. This is the data which will be inside of Raft's normal log entries and the response type which the storage engine will return after applying them to the state machine.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use actix_raft::{AppData, AppDataResponse};
use serde::{Serialize, Deserialize};

/// The application's data type.
///
/// Enum types are recommended as typically there will be different types of data mutating
/// requests which will be submitted by application clients.
#[derive(Clone, Debug, Serialize, Deserialize)]
enum Data {
    // Your data variants go here.
}

/// The application's data response types.
///
/// Enum types are recommended as typically there will be multiple response types which can be
/// returned from the storage layer.
#[derive(Clone, Debug, Serialize, Deserialize)]
enum DataResponse {
    // Your response variants go here.
}

/// This also has a `'static` lifetime constraint, so no `&amp;` references at this time.
/// The new futures &amp; async/await should help out with this quite a lot, so
/// hopefully this constraint will be removed in actix as well.
impl AppData for Data {}

/// This also has a `'static` lifetime constraint, so no `&amp;` references at this time.
impl AppDataResponse for DataResponse {}
<span class="boring">}
</span></code></pre></pre>
<p>Now we'll define the application's error type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use actix_raft::AppError;
use serde::{Serialize, Deserialize};

/// The application's error struct. This could be an enum as well.
///
/// NOTE: the below impls for Display &amp; Error can be
/// derived using crates like `Failure` &amp;c.
#[derive(Debug, Serialize, Deserialize)]
pub struct Error;

impl std::fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        // ... snip ...
    }
}

impl std::error::Error for Error {}

// Mark this type for use as an `actix_raft::AppError`.
impl AppError for Error {}
<span class="boring">}
</span></code></pre></pre>
<p>Now for the two big parts. <code>RaftNetwork</code> &amp; <code>RaftStorage</code>. Here, we will only look at the skeleton for these types. See the <a href="https://railgun-rs.github.io/actix-raft/network.html">network</a> &amp; <a href="https://railgun-rs.github.io/actix-raft/storage.html">storage</a> chapters for more details on how to actually implement these types. First, let's cover the network impl.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Context, ResponseActFuture};
use actix_raft::{RaftNetwork, messages};

/// Your application's network interface actor.
struct AppNetwork {/* ... snip ... */}

impl Actor for AppNetwork {
    type Context = Context&lt;Self&gt;;

    // ... snip ... other actix methods can be implemented here as needed.
}

// Ensure you impl this over your application's data type. Here, it is `Data`.
impl RaftNetwork&lt;Data&gt; for AppNetwork {}

// Then you just implement the various message handlers.
// See the network chapter for details.
impl Handler&lt;messages::AppendEntriesRequest&lt;Data&gt;&gt; for AppNetwork {
    type Result = ResponseActFuture&lt;Self, messages::AppendEntriesResponse, ()&gt;;

    fn handle(&amp;mut self, _msg: messages::AppendEntriesRequest&lt;Data&gt;, _ctx: &amp;mut Self::Context) -&gt; Self::Result {
        // ... snip ...
<span class="boring">        actix::fut::err(())
</span>    }
}

// Impl handlers on `AppNetwork` for the other `actix_raft::messages` message types.
<span class="boring">}
</span></code></pre></pre>
<p>Now for the storage impl. We'll use an <code>actix::Context</code> here (which is async), but you could also use an <code>actix::SyncContext</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Context, ResponseActFuture};
use actix_raft::{NodeId, RaftStorage, storage};

/// Your application's storage interface actor.
struct AppStorage {/* ... snip ... */}

// Ensure you impl this over your application's data, data response &amp; error types.
impl RaftStorage&lt;Data, DataResponse, Error&gt; for AppStorage {
    type Actor = Self;
    type Context = Context&lt;Self&gt;;
}

impl Actor for AppStorage {
    type Context = Context&lt;Self&gt;;

    // ... snip ... other actix methods can be implemented here as needed.
}

// Then you just implement the various message handlers.
// See the storage chapter for details.
impl Handler&lt;storage::GetInitialState&lt;Error&gt;&gt; for AppStorage {
    type Result = ResponseActFuture&lt;Self, storage::InitialState, Error&gt;;

    fn handle(&amp;mut self, _msg: storage::GetInitialState&lt;Error&gt;, _ctx: &amp;mut Self::Context) -&gt; Self::Result {
        // ... snip ...
<span class="boring">        actix::fut::err(())
</span>    }
}

// Impl handlers on `AppStorage` for the other `actix_raft::storage` message types.
<span class="boring">}
</span></code></pre></pre>
<p>In order for Raft to expose metrics on how it is doing, we will need a type which can receive <code>RaftMetrics</code> messages. Application's can do whatever they want with this info. Expose integrations with Prometheus &amp; Influx, trigger events, whatever is needed. Here we will keep it simple.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use actix::{Actor, Context};
use actix_raft::RaftMetrics;

/// Your application's metrics interface actor.
struct AppMetrics {/* ... snip ... */}

impl Actor for AppMetrics {
    type Context = Context&lt;Self&gt;;

    // ... snip ... other actix methods can be implemented here as needed.
}

impl Handler&lt;RaftMetrics&gt; for AppMetrics {
    type Result = ();

    fn handle(&amp;mut self, _msg: RaftMetrics, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        // ... snip ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And finally, a simple type alias which ties everything together. This type alias can then be used throughout the application's code base without the need to specify the various types being used for data, errors, network &amp; storage.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use actix_raft::Raft;

/// A type alias used to define an application's concrete Raft type.
type AppRaft = Raft&lt;Data, DataResponse, Error, AppNetwork, AppStorage&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#booting-up-the-system" id="booting-up-the-system">booting up the system</a></h3>
<p>Now that the various needed types are in place, the actix system will need to be started, the various actor types we've defined above will need to be started, and then we're off to the races.</p>
<pre><pre class="playpen"><code class="language-rust">use actix;
use actix_raft::{Config, ConfigBuilder, SnapshotPolicy};

fn main() {
    // Build the actix system.
    let sys = actix::System::new(&quot;my-awesome-app&quot;);

    // Build the needed runtime config for Raft specifying where
    // snapshots will be stored. See the storage chapter for more details.
    let config = Config::build(String::from(&quot;/app/snapshots&quot;)).validate().unwrap();

    // Start off with just a single node in the cluster. Applications
    // should implement their own discovery system. See the cluster
    // formation chapter for more details.
    let members = vec![1];

    // Start the various actor types and hold on to their addrs.
    let network = AppNetwork.start();
    let storage = AppStorage.start();
    let metrics = AppMetrics.start();
    let app_raft = AppRaft::new(1, config, network, storage, metrics).start();

    // Run the actix system. Unix signals for termination &amp;
    // graceful shutdown are automatically handled.
    let _ = sys.run();
}
</code></pre></pre>
<hr />
<p>You've already ascended to the next level of AWESOME! There is a lot more to cover, we're just getting started. Next, let's take a look at the <code>Raft</code> type in more detail.</p>
<h1><a class="header" href="#raft" id="raft">Raft</a></h1>
<p>The central most type of this crate is the <code>Raft</code> type. It is a highly generic actor with the signature:</p>
<pre><code>Raft&lt;D: AppData, R: AppDataResponse, E: AppError, N: RaftNetwork&lt;D&gt;, S: RaftStorage&lt;D, R, E&gt;&gt;
</code></pre>
<p>The generics here allow <code>Raft</code> to use statically known types, defined in the parent application using this crate, for maximum performance and type-safety. Users of this Raft implementation get to choose the exact types they want to use for application specific error handling coming from the storage layer, and also get to work with their application's data types directly without the overhead of serializing and deserializing the data as it moves through the <code>Raft</code> system.</p>
<h3><a class="header" href="#api" id="api">API</a></h3>
<p>As the <code>Raft</code> type is an Actix <a href="https://docs.rs/actix/latest/actix/trait.Actor.html"><code>Actor</code></a>, all interaction with <code>Raft</code> is handled via message passing. All pertinent message types derive the serde traits for easier integration with other data serialization formats in the Rust ecosystem, providing maximum flexibility for applications using this crate.</p>
<p>All message types are sent to a <code>Raft</code> node via the actor's <a href="https://docs.rs/actix/latest/actix/struct.Addr.html"><code>Addr</code></a>. Applications using this crate are expected to have networking capabilities for cluster communication &amp; client interaction. Applications are responsible for handling client requests &amp; Raft RPCs coming from their network layer, and must send them to the <code>Raft</code> actor returning the response. More details on this topic can be found in the <a href="https://railgun-rs.github.io/actix-raft/network.html">network chapter</a>.</p>
<p>The public API of the <code>Raft</code> type is broken up into 3 sections: Client Requests, Raft RPCs &amp; Admin Commands.</p>
<h5><a class="header" href="#client-requests" id="client-requests">Client Requests</a></h5>
<ul>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.ClientPayload.html">ClientPayload</a>: a payload of data which needs to be committed to the Raft cluster. Typically, this will be data coming from application clients.</li>
</ul>
<h5><a class="header" href="#raft-rpcs" id="raft-rpcs">Raft RPCs</a></h5>
<ul>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.AppendEntriesRequest.html">AppendEntriesRequest</a>: An RPC invoked by the leader to replicate log entries (§5.3); also used as heartbeat (§5.2).</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.VoteRequest.html">VoteRequest</a>: An RPC invoked by candidates to gather votes (§5.2).</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.InstallSnapshotRequest.html">InstallSnapshotRequest</a>: Invoked by the Raft leader to send chunks of a snapshot to a follower (§7).</li>
</ul>
<h5><a class="header" href="#admin-commands" id="admin-commands">Admin Commands</a></h5>
<ul>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.InitWithConfig.html">InitWithConfig</a>: Initialize a pristine Raft node with the given config &amp; start a campaign to become leader.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.ProposeConfigChange.html">ProposeConfigChange</a>: Propose a new membership config change to a running cluster.</li>
</ul>
<h3><a class="header" href="#client-requests-diagram" id="client-requests-diagram">client requests diagram</a></h3>
<p>The following diagram shows how client requests are presented to Raft from within an application, how the data is stored, replicated and ultimately applied to the application's state machine.</p>
<p>
    <img src="./images/raft-workflow-client-requests.png"/>
</p>
<p>The numbered elements represent segments of the workflow.</p>
<ol>
<li>The parent application has received a client request, and presents the payload to <code>Raft</code> using the <code>ClientPayload</code> type.</li>
<li><code>Raft</code> will present the payload to the <code>RaftStorage</code> impl via the <code>AppendEntryToLog</code> type. This is the one location where the <code>RaftStorage</code> impl may return an application specific error. This could be for validation logic, enforcing unique indices, data/schema validation; whatever application level rules the application enforces, this is where they should be enforced. Close to the data, just before it hits the <code>Raft</code> log.</li>
<li>The <code>RaftStorage</code> impl responds to the <code>Raft</code> actor. If it is successful, go to step 4, else the error response will be sent back to the caller immediately. The error response is a statically known type defined by the parent application.</li>
<li><code>Raft</code> uses the <code>RaftNetwork</code> impl to communicate with the peers of the cluster.</li>
<li><code>Raft</code> uses the <code>RaftNetwork</code> impl to replicate the entry to all other nodes in the cluster.</li>
<li>Follower nodes in the cluster respond upon successful replication.</li>
<li>Once the entry has been replicated to a majority of nodes in the cluster — known as a &quot;committed&quot; entry in the Raft spec — it is ready to be applied to the application's state machine.</li>
<li><code>Raft</code> will apply the entry to the application's state machine via the <code>ApplyEntryToStateMachine</code> type.</li>
<li>The <code>RaftStorage</code> impl responds to the <code>Raft</code> actor.</li>
<li>The success response is returned to the caller.</li>
</ol>
<p><strong>NOTE:</strong> this implementation of Raft offers the option for client requests to receive a response once its entry has been committed, and before it is applied to the state machine. This is controlled by the <code>ClientPayload.response_type</code> field, which is an instance of the <code>ResponseMode</code> enum which may be either <code>Committed</code> or <code>Applied</code>. Application's may use either depending on their needs.</p>
<hr />
<p>The API is simple enough, but there is more to learn about <code>Raft</code> than just feeding it messages. The next logical topic to understand is <a href="https://railgun-rs.github.io/actix-raft/network.html">Raft networking</a>.</p>
<h1><a class="header" href="#network" id="network">Network</a></h1>
<p>Raft is a distributed consensus protocol, so the ability to send and receive data over a network is integral to the proper functionality of nodes within a Raft cluster.</p>
<p>The network capabilities required by this system are broken up into two parts: the application network &amp; the <code>RaftNetwork</code> trait.</p>
<h3><a class="header" href="#application-network" id="application-network">Application Network</a></h3>
<p>The main role of the application network, in this context, is to handle client requests and then feed them into Raft. There are a few other important things that it will probably need to do as well, depending on the application's needs, here are a few other common networking roles:</p>
<ul>
<li><strong>discovery:</strong> a component which allows the members of an application cluster (its nodes) to discover and communicate with each other. This is not provided by this crate. There are lots of solutions out there to solve this problem. Applications can build their own discovery system by way of DNS, they could use other systems like etcd or consul. The important thing to note here is that once a peer is discovered, it would be prudent for application nodes to maintain a connection with that peer, as heartbeats are very regular, and building network connections is not free.</li>
<li><strong>data format:</strong> the way that data is serialized and sent accross the networking medium. Popular data formats include protobuf, capnproto, flatbuffers, message pack, JSON &amp;c. Applications are responsible for serializing and deserializing the various message types used in this crate for network transmission. Serde is used throughout this system to aid on this front.</li>
</ul>
<p>Applications must be able to facilitate message exchange between nodes reliably.</p>
<h3><a class="header" href="#trait-raftnetwork" id="trait-raftnetwork"><code>trait RaftNetwork</code></a></h3>
<p>This trait defines the requirement of an application's ability to send and receive Raft RPCs.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait RaftNetwork&lt;D&gt;
    where
        D: AppData,
        Self: Actor&lt;Context=Context&lt;Self&gt;&gt;,

        Self: Handler&lt;AppendEntriesRequest&lt;D&gt;&gt;,
        Self::Context: ToEnvelope&lt;Self, AppendEntriesRequest&lt;D&gt;&gt;,

        Self: Handler&lt;InstallSnapshotRequest&gt;,
        Self::Context: ToEnvelope&lt;Self, InstallSnapshotRequest&gt;,

        Self: Handler&lt;VoteRequest&gt;,
        Self::Context: ToEnvelope&lt;Self, VoteRequest&gt;,
{}
<span class="boring">}
</span></code></pre></pre>
<p>Stated simply, all this trait requires is that the implementing type be an Actix <a href="https://docs.rs/actix/latest/actix/trait.Actor.html"><code>Actor</code></a> &amp; that it implement handlers for the following message types:</p>
<ul>
<li><code>AppendEntriesRequest</code></li>
<li><code>InstallSnapshotRequest</code></li>
<li><code>VoteRequest</code></li>
</ul>
<p>The type used to implement <code>RaftNetwork</code> could be the same type used to provide the other networking capabilities of an application, or it could be an independent type. The requirement is that the implementing type must be able to transmit the RPCs it receives on its handlers to the target Raft nodes identified in the RPCs. This trait is used directly by the <code>Raft</code> actor to send heartbeats to other nodes in the Raft cluster to maintain leadership, replicate entries, request votes when an election takes place, and to install snapshots.</p>
<hr />
<p>Now that we've got a solid taste for the network requirements, the next logic topic to understand is <a href="https://railgun-rs.github.io/actix-raft/storage.html">Raft storage</a>.</p>
<h1><a class="header" href="#storage" id="storage">Storage</a></h1>
<p>The way that data is stored and represented is an integral part of every data storage system. Whether it is a SQL or NoSQL database, a columner store, a KV store, or anything which stores data, control over the storage technology and technique is critical.</p>
<p>This implementation of Raft uses the <code>RaftStorage</code> trait to define the behavior needed of an application's storage layer to work with Raft. This is definitely the most complex looking trait in this crate. Ultimately the implementing type must be an Actix <a href="https://docs.rs/actix/latest/actix"><code>Actor</code></a> and it must implement handlers for a specific set of message types.</p>
<p>When creatinga new <code>RaftStorage</code> instance, it would be logical to supply the ID of the parent Raft node as well as the node's snapshot directory. Such information is needed when booting a node for the first time.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait RaftStorage&lt;D, R, E&gt;: 'static
    where
        D: AppData,
        R: AppDataResponse,
        E: AppError,
{
    /// The type to use as the storage actor. Should just be Self.
    type Actor: Actor&lt;Context=Self::Context&gt; +
        Handler&lt;GetInitialState&lt;E&gt;&gt; +
        Handler&lt;SaveHardState&lt;E&gt;&gt; +
        Handler&lt;GetLogEntries&lt;D, E&gt;&gt; +
        Handler&lt;AppendEntryToLog&lt;D, E&gt;&gt; +
        Handler&lt;ReplicateToLog&lt;D, E&gt;&gt; +
        Handler&lt;ApplyEntryToStateMachine&lt;D, R, E&gt;&gt; +
        Handler&lt;ReplicateToStateMachine&lt;D, E&gt;&gt; +
        Handler&lt;CreateSnapshot&lt;E&gt;&gt; +
        Handler&lt;InstallSnapshot&lt;E&gt;&gt; +
        Handler&lt;GetCurrentSnapshot&lt;E&gt;&gt;;

    /// The type to use as the storage actor's context. Should be `Context&lt;Self&gt;` or `SyncContext&lt;Self&gt;`.
    type Context: ActorContext +
        ToEnvelope&lt;Self::Actor, GetInitialState&lt;E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, SaveHardState&lt;E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, GetLogEntries&lt;D, E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, AppendEntryToLog&lt;D, E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, ReplicateToLog&lt;D, E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, ApplyEntryToStateMachine&lt;D, R, E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, ReplicateToStateMachine&lt;D, E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, CreateSnapshot&lt;E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, InstallSnapshot&lt;E&gt;&gt; +
        ToEnvelope&lt;Self::Actor, GetCurrentSnapshot&lt;E&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Actix handlers must be implemented for the following types, all of which are found in the <code>storage</code> module:</p>
<ul>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.GetInitialState.html">GetInitialState</a>: A request from Raft to get Raft's state information from storage.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.SaveHardState.html">SaveHardState</a>: A request from Raft to save its HardState.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.GetLogEntries.html">GetLogEntries</a>: A request from Raft to get a series of log entries from storage.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.AppendEntryToLog.html">AppendEntryToLog</a>: A request from Raft to append a new entry to the log.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.ReplicateToLog.html">ReplicateToLog</a>: A request from Raft to replicate a payload of entries to the log.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.ApplyEntryToStateMachine.html">ApplyEntryToStateMachine</a>: A request from Raft to apply the given log entry to the state machine.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.ReplicateToStateMachine.html">ReplicateToStateMachine</a>: A request from Raft to apply the given log entries to the state machine, as part of replication.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.CreateSnapshot.html">CreateSnapshot</a>: A request from Raft to have a new snapshot created which covers the current breadth of the log.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.InstallSnapshot.html">InstallSnapshot</a>: A request from Raft to have a new snapshot written to disk and installed.</li>
<li><a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.GetCurrentSnapshot.html">GetCurrentSnapshot</a>: A request from Raft to get metadata of the current snapshot.</li>
</ul>
<p>The following sections detail how to implement a safe and correct storage system for Raft using the <code>RaftStorage</code> trait. A very important note to keep in mind: data storage, data layout, data representation ... all of that is up to the implementor of the <code>RaftStorage</code> trait. That's the whole point. Every application is going to have nuances in terms of what they need to do at the storage layer. This is one of the primary locations where an application can innovate and differentiate.</p>
<h3><a class="header" href="#state" id="state">state</a></h3>
<p>This pertains to implementing the <code>GetInitialState</code> &amp; <code>SaveHardState</code> handlers.</p>
<h5><a class="header" href="#getinitialstate" id="getinitialstate"><code>GetInitialState</code></a></h5>
<p>When the storage system comes online, it should check for any state currently on disk. Based on how the storage layer is persisting data, it may have to look in a few locations to get all of the needed data. Once the <a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.InitialState.html"><code>InitialState</code></a> data has been collected, respond.</p>
<h5><a class="header" href="#savehardstate" id="savehardstate"><code>SaveHardState</code></a></h5>
<p>This handler will be called periodically based on different events happening in Raft. Primarily, membership changes and elections will cause this to be called. Implementation is simple. Persist the data in the given <a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.HardState.html"><code>HardState</code></a> to disk, ensure that it can be accurately retrieved even after a node failure, and respond.</p>
<h3><a class="header" href="#log--state-machine" id="log--state-machine">log &amp; state machine</a></h3>
<p>This pertains to implementing the <code>GetLogEntries</code>, <code>AppendEntryToLog</code>, <code>ReplicateToLog</code>, <code>ApplyEntryToStateMachine</code> &amp; <code>ReplicateToStateMachine</code> handlers.</p>
<p>Traditionally, there are a few different terms used to refer to the log of mutations which are to be applied to a data storage system. Write-ahead log (WAL), op-log, there are a few different terms, sometimes with different nuances. In Raft, this is known simply as the log. A log entry describes the &quot;type&quot; of mutation to be applied to the state machine, and the state machine is the actual business-logic representation of all applied log entries.</p>
<h5><a class="header" href="#getlogentries" id="getlogentries"><code>GetLogEntries</code></a></h5>
<p>This will be called at various times to fetch a range of entries from the log. The <code>start</code> field is inclusive, the <code>stop</code> field is non-inclusive. Simply fetch the specified range of logs from the storage medium, and return them.</p>
<h5><a class="header" href="#appendentrytolog" id="appendentrytolog"><code>AppendEntryToLog</code></a></h5>
<p>Called as the direct result of a client request and will only be called on the Raft leader node. <strong>THIS IS THE ONE AND ONLY</strong> <code>RaftStorage</code> handler which is allowed to return errors which will not cause the Raft node to terminate. Reveiw the docs on the <a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.AppendEntryToLog.html"><code>AppendEntryToLog</code></a> type, and you will see that its message response type is the <code>AppError</code> type, which is a statically known error type chosen by the implementor (which was reviewed earlier in the <a href="https://railgun-rs.github.io/actix-raft/raft.html">raft overview chapter</a>).</p>
<p>This is where an application may enforce business-logic rules, such as unique indices, relational constraints, type validation, whatever is needed by the application. If everything checks out, insert the entry at its specified index in the log. <strong>Don't just blindly append,</strong> use the entry's index. There are times when log entries must be overwritten, and Raft guarantees the safety of such operations.</p>
<p><strong>Another very important note:</strong> per the Raft spec in §8, to ensure that client requests are not applied &gt; 1 due to a failure scenario and the client issuing a retry, the Raft spec recommends that applications track client IDs and use serial numbers on each request. This handler may then use that information to reject duplicate request using an application specific error. The application's client may observe this error and treat it as an overall success. This is an application level responsibility, Raft simply provides the mechanism to be able to implement it.</p>
<h5><a class="header" href="#replicatetolog" id="replicatetolog"><code>ReplicateToLog</code></a></h5>
<p>This is similar to <code>AppendEntryToLog</code> except that this handler is only called on followers, and they should never perform validation or falible operations. If this handler returns an error, the Raft node will terminate in order to guard against data corruption. As mentioned previously, there are times when log entries must be overwritten. Raft guarantees the safety of these operations. <strong>Use the index of each entry when inserting into the log.</strong></p>
<h5><a class="header" href="#applyentrytostatemachine" id="applyentrytostatemachine"><code>ApplyEntryToStateMachine</code></a></h5>
<p>Once a log entry is known to be committed (it has been replicated to a majority of nodes in the cluster), the leader will call this handler to apply the entry to the application's state machine. Committed entries will never be removed or overwritten in the log, which is why it is safe to apply the entry to the state machine. To implement this handler, apply the contents of the entry to the application's state machine in whatever way is needed. This handler is allowed to return an application specific response type, which allows the application to return arbitrary information about the process of applying the entry.</p>
<p>For example, if building a SQL database, and the entry calls for inserting a new record and the full row of data needs to be returned to the client, this handler may return such data in its response.</p>
<p>Raft, as a protocol, guarantees strict linearizability. Entries will never be re-applied. The only case where data is removed from the state machine is during some cases of snapshotting where the entire state machine needs to be rebuilt. Read on for more details.</p>
<p><strong>NOTE WELL:</strong> there are times when Raft needs to append blank entries to the log which will end up being applied to the state machine. See §8 for more details. Application's should handle this with a &quot;no-op&quot; variant of their <code>AppDataResponse</code> type.</p>
<h5><a class="header" href="#replicatetostatemachine" id="replicatetostatemachine"><code>ReplicateToStateMachine</code></a></h5>
<p>This is similar to <code>ApplyEntryToStateMachine</code> except that this handler is only called on followers as part of replication, and are not allowed to return response data (as there is nothing to return response data to during replication).</p>
<h3><a class="header" href="#snapshots--log-compaction" id="snapshots--log-compaction">snapshots &amp; log compaction</a></h3>
<p>This pertains to implementing the <code>CreateSnapshot</code>, <code>InstallSnapshot</code> &amp; <code>GetCurrentSnapshot</code>.</p>
<p>The snapshot and log compaction capabilities defined in the Raft spec are fully supported by this implementation. The storage layer is left to the application which uses this Raft implementation, but all snapshot behavior defined in the Raft spec is supported. Additionally, this implemention supports:</p>
<ul>
<li>Configurable snapshot policies. This allows nodes to perform log compacation at configurable intervals.</li>
<li>Leader based <code>InstallSnapshot</code> RPC support. This allows the Raft leader to make determinations on when a new member (or a slow member) should receive a snapshot in order to come up-to-date faster.</li>
</ul>
<p>For clarity, <strong>it is emphasized</strong> that implementing the log compaction &amp; snapshot creation behavior is up to the <code>RaftStorage</code> implementor. This guide is here to help, and §7 of the Raft spec is dedicated to the subject.</p>
<h5><a class="header" href="#createsnapshot" id="createsnapshot"><code>CreateSnapshot</code></a></h5>
<p>This handler is called when the Raft node determines that a snapshot is needed based on the cluster's configured snapshot policy. <code>Raft</code> guarantees that this interface will never be called multiple overlapping times, and it will not be called when an <code>InstallSnapshot</code> operation is in progress.</p>
<p><strong>It is critical to note</strong> that the newly created snapshot must be able to be used to completely and accurately create a state machine. In addition to saving space on disk (log compaction), snapshots are used to bring new Raft nodes and slow Raft nodes up-to-speed with the cluster leader.</p>
<p><strong>implementation algorithm:</strong></p>
<ul>
<li>The generated snapshot should include all log entries starting from entry <code>0</code> up through the index specified by <code>CreateSnapshot.through</code>. This will include any snapshot which may already exist. If a snapshot does already exist, the new log compaction process should be able to just load the old snapshot first, and resume processing from its last entry.</li>
<li>The newly generated snapshot should be written to the configured snapshot directory.</li>
<li>All previous entries in the log should be deleted up to the entry specified at index <code>through</code>.</li>
<li>The entry at index <code>through</code> should be replaced with a new entry created from calling <a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.Entry.html"><code>Entry::new_snapshot_pointer(...)</code></a>.</li>
<li>Any old snapshot will no longer have representation in the log, and should be deleted.</li>
<li>Return a <a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.CurrentSnapshotData.html"><code>CurrentSnapshotData</code></a> struct which contains all metadata pertinent to the snapshot.</li>
</ul>
<h5><a class="header" href="#installsnapshot" id="installsnapshot"><code>InstallSnapshot</code></a></h5>
<p>This handler is called when the leader of the Raft cluster has determined that the subject node needs to receive a new snapshot. This is typically the case when new nodes are added to a running cluster, or if a node has gone offline for some amount of time without being removed from the cluster, or the node is VERY slow.</p>
<p>This message holds an <code>UnboundedReceiver</code> which will stream in new chunks of data as they are received from the Raft leader. See the docs on the <a href="https://docs.rs/actix-raft/latest/actix_raft/storage/struct.InstallSnapshotChunk.html">InstallSnapshotChunk</a> for more info.</p>
<p><strong>implementation algorithm:</strong></p>
<ul>
<li>Upon receiving the request, a new snapshot file should be created on disk.</li>
<li>Every new chunk of data received should be written to the new snapshot file starting at the <code>offset</code> specified in the chunk. Once the chunk has been successfully written, the <code>InstallSnapshotChunk.cb</code> (a <code>oneshot::Sender</code>) should be called to indicate that the storage engine has finished writing the chunk.</li>
<li>If the receiver is dropped, the snapshot which was being created should be removed from disk, and a success response should be returned.</li>
</ul>
<p>Once a chunk is received which is the final chunk of the snapshot (<code>InstallSnapshotChunk.done</code>), after writing the chunk's data, there are a few important steps to take:</p>
<ul>
<li>Create a new entry in the log via the <a href="https://docs.rs/actix-raft/latest/actix_raft/messages/struct.Entry.html"><code>Entry::new_snapshot_pointer(...)</code></a> constructor. Insert the new entry into the log at the specified <code>index</code> of the original <code>InstallSnapshot</code> payload.</li>
<li>If there are any logs older than <code>index</code>, remove them.</li>
<li>If there are any other snapshots in the configured snapshot dir, remove them.</li>
<li>If an existing log entry has same index and term as snapshot's last included entry, retain log entries following it, then return.</li>
<li>Else, discard the entire log leaving only the new snapshot pointer. <strong>The state machine must be rebuilt from the new snapshot.</strong> Return once the state machine has been brought up-to-date.</li>
</ul>
<h5><a class="header" href="#getcurrentsnapshot" id="getcurrentsnapshot"><code>GetCurrentSnapshot</code></a></h5>
<p>A request to get information on the current snapshot. <code>RaftStorage</code> implementations must take care to ensure that there is only ever one active snapshot, old snapshots should be deleted as part of <code>CreateSnapshot</code> and <code>InstallSnapshot</code> requests, and the snapshot information should be able to be retrieved efficiently. Having to load and parse the entire snapshot on each <code>GetCurrentSnapshot</code> request may not be such a great idea! Snapshots can be quite large.</p>
<hr />
<p>Woot woot! Made it through the hard part! There is more to learn, so let's keep going.</p>
<h1><a class="header" href="#cluster-controls" id="cluster-controls">Cluster Controls</a></h1>
<p>Raft nodes may be controlled in various ways outside of the normal flow of the Raft protocol using the <code>admin</code> message types. This allows the parent application — within which the Raft node is running — to influence the Raft node's behavior based on application level needs.</p>
<h3><a class="header" href="#concepts" id="concepts">concepts</a></h3>
<p>In the world of Raft consensus, there are a few aspects of a Raft node's lifecycle which are not directly dictated in the Raft spec. Cluster formation and the preliminary details of what would lead to dynamic cluster membership changes are a few examples of concepts not directly detailed in the spec. This implementation of Raft offers as much flexibility as possible to deal with such details in a way which is safe according to the Raft specification, but also in a way which preserves flexibility for the many different types of applications which may be implemented using Raft.</p>
<h1><a class="header" href="#cluster-formation" id="cluster-formation">Cluster Formation</a></h1>
<p>All Raft nodes, when they first come online in a pristine state, will enter into the <code>NonVoter</code> state, which is a completely passive state. This gives the parent application the ability to issue admin commands to the node based on the intention of the parent application.</p>
<p>To form a new cluster, all application nodes must issue the <code>InitWithConfig</code> command to their embedded Raft nodes with the IDs of all discovered nodes which are to be part of the cluster (including the ID of the running node). Or if the application is to run in a standalone / single-node manner, it may issue the command with only its own ID.</p>
<h4><a class="header" href="#initwithconfig" id="initwithconfig"><code>InitWithConfig</code></a></h4>
<p>This command is used exclusively for the formation of new clusters. This command will fail if the node is not in the <code>NonVoter</code> state, or if the node's log index is not <code>0</code>.</p>
<p>This will cause the Raft node to hold the given configuration in memory and then immediately perform the election protocol. For single-node clusters, the node will immediately become leader, for multi-node clusters it will submit <code>RequestVote</code> RPCs to all of the nodes in the given config list. <strong>NOTE WELL that EVERY node in the cluster MUST perform this action</strong> when a new cluster is being formed. It is safe for all nodes to issue this command in parallel. Once this process has been completed, the newly elected leader will append the given membership config data to the log, ensuring that the new configuration will be reckoned as the initial cluster configuration moving forward throughout the life of the cluster.</p>
<p>However, in order to ensure that multiple independent clusters aren't formed by prematurely issuing the <code>InitWithConfig</code> command before all peers are discovered, it would be prudent to have all discovered node's exchange some information during their handshake protocol. This will allow the parent application to make informed decisions as to whether the <code>InitWithConfig</code> should be called and how early it should be called when starting a new cluster. An application level configuration for this facet is recommended.</p>
<p>Generally speaking, an application config like <code>initial_cluster_formation_delay</code> (or the like), which configures the application to wait for the specifed amount of time before issuing an <code>InitWithConfig</code> command, should do the trick. The value for such a configuration should simply be a few orders of magnitude greater than the amount of time it takes for all the nodes of a new cluster to come online and discover each other.</p>
<p>As a rule of thumb, when new nodes come online, the leader of an existing Raft cluster will eventually discover the node (via the application's discovery system), and in such cases, the application should submit a new <code>ProposeConfigChange</code> to the leader to add it to the cluster. The same goes for removing nodes from the cluster.</p>
<p><strong>For single-node clusters</strong>, scaling up the cluster by adding new nodes via the <code>ProposeConfigChange</code> command should work as expected, but there is one invariant which must be upheld: the original node of the cluster must remain online until at least half of the other new nodes have been brough up-to-date, otherwise the Raft cluster will not be able to make progress. After the other nodes have been brought up-to-date, everything should run normally according to the Raft spec.</p>
<h1><a class="header" href="#dynamic-membership" id="dynamic-membership">Dynamic Membership</a></h1>
<p>Throughout the lifecycle of a Raft cluster, various nodes may need to go offline for various reasons. They may experience hardware or software errors which cause them to go offline when unintended, or perhaps a cluster had too many nodes and it needs to downsize. New nodes may be added to clusters as well in order to replace old nodes, nodes going offline for maintenence, or simply to increase the size of a cluster. Applications may control such events using the <code>ProposeConfigChange</code> command. This command allows for nodes to be safely added and removed form a running Raft cluster.</p>
<h4><a class="header" href="#proposeconfigchange" id="proposeconfigchange"><code>ProposeConfigChange</code></a></h4>
<p>This command will propose a new config change to a running cluster. This command will fail if the Raft node to which this command was submitted is not the Raft leader, and the outcome of the proposed config change must not leave the cluster in a state where it will have less than two functioning nodes, as the cluster would no longer be able to make progress in a safe manner. Once the leader receives this command, the new configuration will be appended to the log and the Raft dynamic configuration change protocol will begin. For more details on how this is implemented, see §6 of the Raft spec.</p>
<p>Cluster auto-healing, where cluster members which have been offline for some period of time are automatically removed, is an application specific behavior, but is fully supported via this dynamic cluster membership system.</p>
<p>Likewise, dynamically adding new nodes to a running cluster based on an application's discovery system is also fully supported by this system.</p>
<h1><a class="header" href="#metrics" id="metrics">Metrics</a></h1>
<p><code>Raft</code> exports metrics on a regular interval in order to facilitate maximum observability and integration with metrics aggregations tools (eg, prometheus, influx &amp;c) using the <a href="https://docs.rs/actix-raft/latest/actix_raft/metrics/struct.RaftMetrics.html"><code>RaftMetrics</code></a> type.</p>
<p>The <code>Raft</code> instance constructor expects a <code>Recipient&lt;RaftMetrics&gt;</code> (an <a href="https://docs.rs/actix/latest/actix/struct.Recipient.html">actix::Recipient</a>) to be supplied, and will use this recipient to export its metrics. The <code>RaftMetrics</code> type holds the baseline metrics on the state of the Raft node the metrics are coming from, its current role in the cluster, its current membership config, as well as information on the Raft log and the last index to be applied to the state machine.</p>
<p>Applications may use this data in whatever way is needed. The obvious use cases are to expose these metrics to a metrics collection system. Applications may also use this data to trigger events within higher levels of the parent application.</p>
<p>Metrics will be exported at a regular interval according to the <a href="https://docs.rs/actix-raft/latest/actix_raft/config/struct.Config.html#structfield.metrics_rate">Config.metrics_rate</a> value, but will also emit a new metrics record any time the <code>state</code> of the Raft node changes, the <code>membership_config</code> changes, or the <code>current_leader</code> changes.</p>
<h1><a class="header" href="#get-to-it" id="get-to-it">Get To It</a></h1>
<p>In my very humble opinion, Rust is an outstanding language for building new databases, data stores, messaging systems and all of the other things. Books have already been written about this, so I will just say in conclusion:</p>
<ul>
<li>We don't need to keep allocating all of the memory of all of the clouds to the JVM.</li>
<li>We ABSOLUTELY need to move away from all of the memory safety issues which have compromised countless systems.</li>
<li>Raft is a robust and powerful consensus protocol.</li>
<li>Huge companies have invested a lot of money in creating actor-based languages specifically for creating database systems (think FoundationDB), and we already have Actix (thanks Nikolay)!</li>
</ul>
<p>There are plenty of awesome things to build! Let's do this!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
